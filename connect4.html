<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 4</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 600px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .status {
            font-size: 1.3em;
            margin: 20px 0;
            font-weight: bold;
            min-height: 40px;
        }
        
        .player1-turn { color: #e74c3c; }
        .player2-turn { color: #3498db; }
        .winner { color: #27ae60; }
        .draw { color: #7f8c8d; }
        
        #board {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 15px;
            display: inline-block;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin: 20px 0;
        }
        
        .row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .row:last-child {
            margin-bottom: 0;
        }
        
        .cell {
            width: 60px;
            height: 60px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .cell:hover:not(.filled) {
            background: #ecf0f1;
            transform: scale(1.05);
        }
        
        .cell.filled {
            cursor: default;
        }
        
        .cell.player1 {
            background: #e74c3c;
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.4);
        }
        
        .cell.player2 {
            background: #3498db;
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.4);
        }
        
        .cell.winning {
            animation: pulse 0.5s ease-in-out 3;
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.8);
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        button {
            padding: 12px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            color: white;
        }
        
        .reset-btn {
            background: #27ae60;
        }
        
        .reset-btn:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
        }
        
        .home-btn {
            background: #3498db;
        }
        
        .home-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding: 15px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 10px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .stat-label {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .red { color: #e74c3c; }
        .blue { color: #3498db; }
        .gray { color: #7f8c8d; }
        
        @media (max-width: 600px) {
            .cell {
                width: 45px;
                height: 45px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .status {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üî¥ Connect 4 üîµ</h1>
        <div class="status player1-turn" id="status">Your Turn</div>
        
        <div id="board"></div>
        
        <div class="controls">
            <button class="reset-btn" onclick="resetGame()">üîÑ New Game</button>
            <button class="home-btn" onclick="window.location.href='/'">üè† Home</button>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-label">Your Wins</div>
                <div class="stat-value red" id="redWins">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">J4RV1S Wins</div>
                <div class="stat-value blue" id="blueWins">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Draws</div>
                <div class="stat-value gray" id="draws">0</div>
            </div>
        </div>
    </div>
    
    <script>
        const ROWS = 6;
        const COLS = 7;
        let board = [];
        let currentPlayer = 1; // 1 = red, 2 = blue
        let gameOver = false;
        let stats = {
            redWins: parseInt(localStorage.getItem('connect4RedWins') || '0'),
            blueWins: parseInt(localStorage.getItem('connect4BlueWins') || '0'),
            draws: parseInt(localStorage.getItem('connect4Draws') || '0')
        };
        
        function initBoard() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            currentPlayer = 1;
            gameOver = false;
            
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < ROWS; row++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'row';
                
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.onclick = () => dropPiece(col);
                    rowDiv.appendChild(cell);
                }
                
                boardElement.appendChild(rowDiv);
            }
            
            updateStatus();
            updateStats();
        }
        
        function dropPiece(col) {
            if (gameOver || currentPlayer === 2) return; // Prevent player moves during AI turn
            
            // Find the lowest empty row in this column
            let row = -1;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][col] === 0) {
                    row = r;
                    break;
                }
            }
            
            if (row === -1) return; // Column is full
            
            // Place the piece
            board[row][col] = currentPlayer;
            
            // Update the visual
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            cell.classList.add('filled', currentPlayer === 1 ? 'player1' : 'player2');
            
            // Check for win
            if (checkWin(row, col)) {
                gameOver = true;
                const winner = currentPlayer === 1 ? 'You Win' : 'J4RV1S Wins';
                document.getElementById('status').textContent = `${winner}! üéâ`;
                document.getElementById('status').className = 'status winner';
                
                // Update stats
                if (currentPlayer === 1) {
                    stats.redWins++;
                    localStorage.setItem('connect4RedWins', stats.redWins);
                } else {
                    stats.blueWins++;
                    localStorage.setItem('connect4BlueWins', stats.blueWins);
                }
                updateStats();
                return;
            }
            
            // Check for draw
            if (checkDraw()) {
                gameOver = true;
                document.getElementById('status').textContent = "It's a Draw! ü§ù";
                document.getElementById('status').className = 'status draw';
                stats.draws++;
                localStorage.setItem('connect4Draws', stats.draws);
                updateStats();
                return;
            }
            
            // Switch player
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateStatus();
            
            // AI's turn
            if (currentPlayer === 2 && !gameOver) {
                setTimeout(() => aiMove(), 500);
            }
        }
        
        function aiMove() {
            if (gameOver) return;
            
            // AI strategy: prioritize winning, then blocking, then center, then random
            let bestCol = -1;
            
            // 1. Check if AI can win in next move
            bestCol = findWinningMove(2);
            
            // 2. Check if need to block player from winning
            if (bestCol === -1) {
                bestCol = findWinningMove(1);
            }
            
            // 3. Try to play in center columns (better strategic position)
            if (bestCol === -1) {
                const centerCols = [3, 2, 4, 1, 5, 0, 6];
                for (let col of centerCols) {
                    if (isValidMove(col)) {
                        bestCol = col;
                        break;
                    }
                }
            }
            
            // 4. Fallback to random valid move
            if (bestCol === -1) {
                const validCols = [];
                for (let col = 0; col < COLS; col++) {
                    if (isValidMove(col)) validCols.push(col);
                }
                if (validCols.length > 0) {
                    bestCol = validCols[Math.floor(Math.random() * validCols.length)];
                }
            }
            
            if (bestCol !== -1) {
                // Find row for this column
                let row = -1;
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (board[r][bestCol] === 0) {
                        row = r;
                        break;
                    }
                }
                
                if (row !== -1) {
                    // Place AI piece
                    board[row][bestCol] = 2;
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${bestCol}"]`);
                    cell.classList.add('filled', 'player2');
                    
                    // Check for AI win
                    if (checkWin(row, bestCol)) {
                        gameOver = true;
                        document.getElementById('status').textContent = 'J4RV1S Wins! üéâ';
                        document.getElementById('status').className = 'status winner';
                        stats.blueWins++;
                        localStorage.setItem('connect4BlueWins', stats.blueWins);
                        updateStats();
                        return;
                    }
                    
                    // Check for draw
                    if (checkDraw()) {
                        gameOver = true;
                        document.getElementById('status').textContent = "It's a Draw! ü§ù";
                        document.getElementById('status').className = 'status draw';
                        stats.draws++;
                        localStorage.setItem('connect4Draws', stats.draws);
                        updateStats();
                        return;
                    }
                    
                    // Back to player
                    currentPlayer = 1;
                    updateStatus();
                }
            }
        }
        
        function findWinningMove(player) {
            // Try each column to see if it results in a win
            for (let col = 0; col < COLS; col++) {
                if (!isValidMove(col)) continue;
                
                // Find row
                let row = -1;
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (board[r][col] === 0) {
                        row = r;
                        break;
                    }
                }
                
                if (row !== -1) {
                    // Simulate move
                    board[row][col] = player;
                    const wins = checkWin(row, col);
                    board[row][col] = 0; // Undo
                    
                    if (wins) return col;
                }
            }
            return -1;
        }
        
        function isValidMove(col) {
            return board[0][col] === 0;
        }
        
        function checkWin(row, col) {
            const player = board[row][col];
            const directions = [
                [[0, 1], [0, -1]],   // Horizontal
                [[1, 0], [-1, 0]],   // Vertical
                [[1, 1], [-1, -1]],  // Diagonal \
                [[1, -1], [-1, 1]]   // Diagonal /
            ];
            
            for (let [dir1, dir2] of directions) {
                let count = 1;
                const winningCells = [[row, col]];
                
                // Check in first direction
                for (let [dr, dc] of [dir1]) {
                    let r = row + dr;
                    let c = col + dc;
                    while (r >= 0 && r < ROWS && c >= 0 && c < COLS && board[r][c] === player) {
                        count++;
                        winningCells.push([r, c]);
                        r += dr;
                        c += dc;
                    }
                }
                
                // Check in opposite direction
                for (let [dr, dc] of [dir2]) {
                    let r = row + dr;
                    let c = col + dc;
                    while (r >= 0 && r < ROWS && c >= 0 && c < COLS && board[r][c] === player) {
                        count++;
                        winningCells.push([r, c]);
                        r += dr;
                        c += dc;
                    }
                }
                
                if (count >= 4) {
                    // Highlight winning cells
                    winningCells.forEach(([r, c]) => {
                        const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        cell.classList.add('winning');
                    });
                    return true;
                }
            }
            
            return false;
        }
        
        function checkDraw() {
            return board[0].every(cell => cell !== 0);
        }
        
        function updateStatus() {
            const status = document.getElementById('status');
            if (currentPlayer === 1) {
                status.textContent = "Your Turn üî¥";
                status.className = 'status player1-turn';
            } else {
                status.textContent = "J4RV1S is thinking... üîµ";
                status.className = 'status player2-turn';
            }
        }
        
        function updateStats() {
            document.getElementById('redWins').textContent = stats.redWins;
            document.getElementById('blueWins').textContent = stats.blueWins;
            document.getElementById('draws').textContent = stats.draws;
        }
        
        function resetGame() {
            initBoard();
        }
        
        // Initialize game on load
        initBoard();
    </script>
</body>
</html>
